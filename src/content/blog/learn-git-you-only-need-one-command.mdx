---
title: "Git: You Only Need Two Commands"
description: "A practical guide to using git for code generation workflows - you only need to know how to commit code."
pubDate: 2026-01-29T00:00:00.000Z
author: "Brendan O'Neill"
tags: ["Git", "Development", "Best Practices"]
draft: false
---

import CodeDisplay from '../../components/CodeDisplay.astro';
import Prompt from '../../components/Prompt.astro';
import Takeaway from '../../components/Takeaway.astro';
import Technicallity from '../../components/Technicallity.astro';

If you aren't using git, stop developing and invest an hour in learning ittoday. I guarantee you'll see a full ROI within a week.

Git might sound complicated, but the thing is, to 'glide code' you only really need to know how to do two commands: commit and reset your code.

<Technicallity>
*Well, technically it's three commands, but you only need to learn how to do two things.
</Technicallity>

## 1. Committing Code
'Committing' code essentially saves your codebase at a certain point in time. So when you're happy with your code, you create a commit and then if you want to get back to that code, all you have to do is enter:

You can commit code with two really simple commands in the terminal:

<CodeDisplay language="bash">
{`git add .
git commit -m "Message describing the commit"`}
</CodeDisplay>

## 2. Resetting Code
'Resetting' your code instantly drops all the code that you've written or generated but **haven't yet committed**. In the long run, this command is going to save you hours.

<CodeDisplay language="bash">
{`git reset --hard`}
</CodeDisplay>

You might not believe me just yet, but you soon will. Here's why:

- Agents are prone to getting into error loops - when this happens, it makes it difficult to get back because as more wonky code is generated, it becomes part of the prompt. A lot of the time, from these loops you'll have a much better idea of what's going on, so resetting and giving a more detailed prompt will do the trick much faster than trying to prompt your way backwards
- You can experiment risk-free. You think a transition will look good, you prompt to add a transition, it's not great, you test it out a bit more, you've updated 3 files now trying to get this working and you finally get it working but it's not as good as you thought - `git reset --hard`, no need to backtrack

## Using Git

As you use these simple steps in your development workflow, the use cases will become very clear very quickly.

Here's a real-world example - you're building a TODO list app and you want users to be able to:

'Set an item as high priority'.

So think through that - you want to:
1. Add a 'High Priority' Button
2. Update the item to show if it is 'High Priority' when the user clicks the button
3. Move 'High Priority' items to a new list at the top of the screen

<Prompt>
Add a button that is a flag icon on the right hand side of the TODO item so the user can set the item as a priority of "HIGH"
</Prompt>

*Adds button - you're happy*

<CodeDisplay language="bash">
{`git add .
git commit -m "Add High Priority Button"`}
</CodeDisplay>

<Prompt>
Create a separate list shown at the top of the screen for 'High Priority TODO items'
</Prompt>

*Adds list - you're happy*

<CodeDisplay language="bash">
{`git add .
git commit -m "Add High Priority List at the top of the screen"`}
</CodeDisplay>

Looks great when it's static and you know you're happy. But now you want to add a nice transition.

<Prompt>
When a user sets an item to high priority, have a nice transition that moves it from the normal list to the 'High Priority' list.
</Prompt>

You're not happy, it's a bit jumpy, but you think about it and you realise how you want it to work.

<Prompt>
No, that's not really working, it's a bit jumpy. Make the item slide out of the 'normal priority' list from left to right and then slide in to the 'high priority' list from left to right.
</Prompt>

It changes some code, but follows a pattern from the previous prompt but it leaves you with something that is a weird mix of the original jumpy transition and the newly requested sliding one.

So...

<CodeDisplay language="bash">
{`git reset --hard`}
</CodeDisplay>

This will reset your code back to your last commit. Now we've gotten rid of the code that has spiralled and gone a bit wonky and we're back to our nice clean code that we're happy with.

Open a new agent. Copy and paste the file for context and then prompt.

<Prompt>
When a user sets an item to high priority, make the item slide out of the 'normal priority' list from left to right and then slide in to the 'high priority' list from left to right.
</Prompt>

Perfect. This has a much better chance of coming out as you planned. You experimented, got a better understnading of what exactly you want and it was super simple to get back into a position to give a more detailed prompt without having to regenrate the things you were happy with; the button, the feedback, and the list!

So finally, commit your finished feature.

<CodeDisplay language="bash">
{`git add .
git commit -m "Add transition for high priority item"`}
</CodeDisplay>

This might slow you down a little bit at first but overall you will save A LOT of time. Especially when you start running into errors!

<Takeaway>
Get into the habit of committing code **early** and **often**.
</Takeaway>

As you get further into your code it becomes more and more important as the codebase gets bigger and the generated code gets more unstable and unreliable.

When you've got that down, you can take a look at branches, which really aren't that much more complicated, which also, I'll touch on in a later article.
